<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19287248-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-19287248-2');
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Python adapter for PostgreSQL" />
    <meta name="keywords" content="python, postgresql, adapter, driver, psycopg, psycopg2, database" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/syntax.css?h=8242465b">
    <link rel="stylesheet" href="/css/psycopg.css?h=a6123e9d">
    <title>Articles tagged development â€” Psycopg</title>
  </head>
  <body>
    <header>
      <div id="logoContainer" class="container">
        <div id="logo"><h1><a href="/">psycopg</a></h1></div>
        <div style="clear: left"></div>
      </div>
  <nav id="menu" class="navbar navbar-expand-sm navbar-dark">
    <button class="navbar-toggler" type="button" data-toggle="collapse"
        data-target="#collapsibleNavbar">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="collapsibleNavbar">
      <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/features/">Features</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/install/">Install</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/articles/tag/news/">News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/articles/tag/recipe/">Recipes</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/psycopg3/">psycopg3</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/sponsors/">Sponsors</a>
          </li>
      </ul>
    </div>
  </nav>
    </header>

    <div id="site" class="container" style="margin-top:30px">
      <div class="row">
        <div id="content" class="offset-sm-1 col-sm-10">
        
  <h1>Articles tagged <em>development</em></h1>
  
    
  <div class="article">
  
    <h2><a href="/articles/2024/09/23/async-to-sync/">Automatic async to sync code conversion</a></h2>
  
  <p class="header">
    Posted by Daniele Varrazzo on 2024-09-23
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/psycopg3/"
          >psycopg3</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>
      
    
  </p>
  
    <p>Psycopg 3 provides both a sync and an async Python interface: for each object
used to perform I/O operations, such as <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/api/connections.html#psycopg.Connection">Connection</a>, <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/api/cursors.html#psycopg.Cursor">Cursor</a>, there is an
async counterpart: <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/api/connections.html#psycopg.AsyncConnection">AsyncConnection</a>, <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/api/cursors.html#psycopg.AsyncCursor">AsyncCursor</a>, with an intuitive
interface: just add the right <tt class="docutils literal">async</tt> or <tt class="docutils literal">await</tt> keyword where needed:</p>
<pre class="code python literal-block">
<span class="c1"># Familiar sync code</span><span class="w">
</span><span class="n">conn</span> <span class="o">=</span> <span class="n">psycopg</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="w">
</span><span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select now()&quot;</span><span class="p">)</span><span class="w">
</span><span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="w">

</span><span class="c1"># Similar async code</span><span class="w">
</span><span class="n">aconn</span> <span class="o">=</span> <span class="k">await</span> <span class="n">psycopg</span><span class="o">.</span><span class="n">AsyncConnection</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="w">
</span><span class="n">acur</span> <span class="o">=</span> <span class="k">await</span> <span class="n">aconn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select now()&quot;</span><span class="p">)</span><span class="w">
</span><span class="nb">print</span><span class="p">((</span><span class="k">await</span> <span class="n">acur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
</pre>
<p>The decision to provide both sync and async code <a class="reference external" href="https://www.varrazzo.com/blog/2020/03/26/psycopg3-first-report/">was made early in the
development of Psycopg 3</a> and most of the internal code is written in a way
to be compatible with both sync and async code, in order to keep code
duplication to a minimum. This was achieved by making all the libpq
communication async, and writing the network code as generators,
<tt class="docutils literal">yield</tt>ing at the moment they need to wait, isolating the differences in
the sync/async wait policy all in <tt class="docutils literal">wait()</tt> functions.</p>
<p>This helped to minimise the async/sync differences in the code related to the
communication between PostgreSQL and Psycopg. However, the interface between
Psycopg and the Python user is still a lot to maintain, and consists of a lot
of code that is very similar, almost duplicated, between the sync and async
sided. Apart from the obvious <tt class="docutils literal">async</tt>/<tt class="docutils literal">await</tt> keywords, there would be
subtle implementation differences, for example:</p>
<ul class="simple">
<li>using <tt class="docutils literal">asyncio</tt> functions instead of blocking counterparts, for instance
<tt class="docutils literal">await asyncio.sleep()</tt> instead of <tt class="docutils literal">time.sleep()</tt>;</li>
<li><tt class="docutils literal">asyncio.create_task(f(arg1, arg2))</tt> is similar to <tt class="docutils literal">thread.Thread(f,
(arg1, <span class="pre">arg2)).start()</span></tt>;</li>
<li><tt class="docutils literal">threading.Event</tt> has a <tt class="docutils literal">asyncio.Event</tt> counterpart whose <tt class="docutils literal">lock()</tt>
method doesn't have a <tt class="docutils literal">timeout</tt>, parameter, so <tt class="docutils literal">event.wait(timeout=10)</tt>
needs to be rewritten as <tt class="docutils literal"><span class="pre">asyncio.wait_for(event.wait(),</span> timeout=10)</tt>.</li>
</ul>
<p>Up until Psycopg 3.1, the two variants of each object were kept in sync
manually. Every time changes were made on the sync side, they had to be ported
to the async side, with cumbersome and noisy diffs, with subtle differences
being introduced from time to time. Even the tests were pretty much duplicated
(with some sync tests being accidentally lost on the async side, or vice
versa). It seemed like a situation that could have been improved.</p>
<div class="section" id="this-is-so-boring-that">
<h2>This is so boring that...</h2>
<p>...a computer should do it for me instead.</p>
<p>Writing the async side starting from the sync side? Actually, the opposite. It
is obvious that the async side has more information than the sync side (every
method definition and call clearly indicates whether it will block or not) and
most of the differences are minimal and repetitive. What we want then is <em>a
script that takes asyncio-based source code as input and outputs
equivalent sync code</em>.</p>
<p>This article describes what we did to implement such a script and how we used
it for the initial transformation (replacing manually written sync code with
auto-generated code without loss of quality) and how we are currently using it
to maintain the Psycopg 3 codebase.</p>
</div>
<div class="section" id="abstract-syntax-tree">
<h2>Abstract Syntax Tree</h2>
<p>You would be tempted to write a bunch of regular expressions to just scrub
away every <tt class="docutils literal">async</tt> and <tt class="docutils literal">await</tt> keyword found, but the source code is
probably the wrong level to attack the problem: Python knows how to parse
Python itself well and can allow us to reason at a higher level.</p>
<p>A better tool to work with is the <a class="reference external" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST): an in-memory
representation of the code obtained after parsing. At this level we manipulate
objects that represent &quot;the for loop&quot;, or &quot;the function call&quot;, and we are not
fooled by unexpected spaces, extra brackets, comments, literal strings, and
other traps.</p>
<p>The <a class="reference external" href="https://docs.python.org/3/library/ast.html">Python 'ast' module</a> is the obvious starting point: if you have a bit
of source code such as:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">asyncio</span><span class="w">

</span><span class="k">async</span> <span class="k">def</span> <span class="nf">async_square</span><span class="p">(</span><span class="n">n</span><span class="p">):</span><span class="w">
</span>    <span class="c1"># Squares are slow</span><span class="w">
</span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">

</span>    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span>
</pre>
<p>you can pass it to the module to see the AST tree that represents it:</p>
<pre class="literal-block">
$ python -m ast ast1.py
<strong>Module</strong>(
   body=[
      <strong>Import</strong>(
         names=[
            alias(name='asyncio')]),
      <strong>AsyncFunctionDef</strong>(
         name='async_square',
         args=arguments(
            args=[
               arg(arg='n')],
            defaults=[]),
         body=[
            Expr(
               value=<strong>Await</strong>(
                  value=<strong>Call</strong>(
                     func=Attribute(
                        value=Name(id='asyncio'),
                        attr='sleep'),
                     args=[
                        Constant(value=1)]))),
            <strong>Return</strong>(
               value=BinOp(
                  left=Name(id='n'),
                  op=Mult(),
                  right=Name(id='n')))],
         decorator_list=[],
         returns=Name(id='float'))])
</pre>
<p>You can see, highlighted, the nodes in the tree representing the main
statements in the code: the tree represents a <em>module</em>, whose body contains two
<em>statements</em> - an <tt class="docutils literal">import</tt> and an <tt class="docutils literal">async def</tt> - with the function body
defining an <tt class="docutils literal">await</tt> call and a <tt class="docutils literal">return</tt> statement.</p>
<p>The same <tt class="docutils literal">ast</tt> module can perform the reverse transformation, converting an
AST tree back to source:</p>
<pre class="literal-block">
$ python -c &quot;import ast; print(ast.unparse(ast.parse(open('ast1.py').read())))&quot;
import asyncio

async def square(n: float) -&gt; float:
    await asyncio.sleep(1)
    return n * n
</pre>
<p>As you can see, the transformation back to code is unfortunately not a perfect
reconstruction of the original code, it is only <em>equivalent</em>, with missing
comments and different spacing. This is because the syntax tree is <em>abstract</em>
and whitespaces and comments don't affect it. If you wanted to take those
details into account you would need a <em>concrete</em> syntax tree (<a class="reference external" href="https://pypi.org/project/libcst/">something like
that exists</a>, but I haven't played with it).</p>
<p>Changing whitespaces is not a problem, but losing comments can be, especially
when they are used to control linters (such as Flake8's <tt class="docutils literal">noqa</tt> or Mypy's
<tt class="docutils literal">type: ignore</tt>), or simply when you happen to be a human being and want to
read the source code. Fortunately there is a simple wrapper module,
<a class="reference external" href="https://pypi.org/project/ast-comments/">ast-comments</a>, which does exactly what it says on the tin: it introduces
<tt class="docutils literal">Comment</tt> nodes as part of an AST. Playing around with it, it turned out to
be a good compromise between an abstract and a concrete syntax tree, after
some taming of the comments placement.</p>
</div>
<div class="section" id="du-ast-mich">
<h2>Du AST Mich</h2>
<p>To perform the code transformation, we will walk over the abstract
syntax tree and we will perform some operation to generate a different tree of
our liking. Typically, this type of operation is performed using an
implementation of the <a class="reference external" href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a>.</p>
<p>This pattern can be incredibly useful whenever you need to perform operations
on data structures composed of heterogeneous nodes (I've seen it in
applications ranging from converting UML representations to code, converting
markup language to HTML, converting Kubernetes manifests to Helm charts,
converting annotated lyrics files to Ukulele tab sheets...); unfortunately
many of the descriptions of the pattern you can find online fail to make its
brilliance immediately apparent (the Wikipedia page is pretty bad at it)
because they have historically focused on solving the <em>double-dispatch</em>
problem in static languages like as C++ or Java (which is trivial in a dynamic
language like Python) rather than focusing on the <strong>awesome</strong> things you
can do with it.</p>
<p>In a nutshell, you will have an object that traverses an input data structure,
element by element, building an output structure in the process, allowing you
to run different code and to perform different manipulations depending on the
type of element being traversed.</p>
<p>In our case, both the input and the output are AST trees, which will happen to
be very similar to each other (since we are just trying to translate some
subtle differences from one Python module to another): for many nodes, the
visitor will just output a copy of it (for example, the <tt class="docutils literal">return</tt> statement
in the above example is unchanged). But, if we see a pattern of interest, we
can tell our visitor to produce a different node.</p>
<p>The <tt class="docutils literal">ast</tt> module provides a base class <a class="reference external" href="https://docs.python.org/3/library/ast.html#ast.NodeTransformer">ast.NodeTransformer</a> which
implements the node traversal and tree production parts. By itself it
doesn't perform any operations on the nodes, so it just produces a copy of the
input tree. However, by subclassing the class and adding visit methods, you
can implement node-specific transformations.</p>
<p>With the AST node transformer, the method called is based on the name of the
node being visited; for example, if you add a method called <tt class="docutils literal">visit_Import</tt>
to your subclass, the visitor will call it whenever it traverses an <tt class="docutils literal">Import</tt>
node, giving you the chance to manipulate an <tt class="docutils literal">import</tt> statement. You can
then decide whether you want to change some of the details of the node (drop
some imports, change some names), or replace the node with something completely
different (such as replacing an async function definition with a sync one).</p>
<p>Let's say that we want to produce a sync version of the above script: the
differences should be the following:</p>
<pre class="code diff literal-block">
<span class="gu">&#64;&#64; -1,7 +1,7 &#64;&#64;</span><span class="w">
</span><span class="gd">-import asyncio</span><span class="w">
</span><span class="gi">+import time</span><span class="w">

</span><span class="gd">-async def async_square(n: float) -&gt; float:</span><span class="w">
</span><span class="gi">+def square(n: float) -&gt; float:</span><span class="w">
 </span>    # Squares are slow<span class="w">
</span><span class="gd">-    await asyncio.sleep(1)</span><span class="w">
</span><span class="gi">+    time.sleep(1)</span><span class="w">

 </span>    return n * n
</pre>
<p>In our toy example, we want to convert the <tt class="docutils literal">asyncio</tt> module into the <tt class="docutils literal">time</tt>
module (which is obviously not the right thing to do in the general case, but
let's keep the example simple). The following script implements the
transformation and prints the converted module:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">ast</span><span class="w">

</span><span class="k">class</span> <span class="nc">MyTransformer</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeTransformer</span><span class="p">):</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">visit_Import</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span><span class="w">
</span>        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">:</span><span class="w">
</span>            <span class="k">if</span> <span class="n">alias</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;asyncio&quot;</span><span class="p">:</span><span class="w">
</span>                <span class="n">alias</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="w">

</span>        <span class="k">return</span> <span class="n">node</span><span class="w">

</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;ast1.py&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span><span class="w">
</span>    <span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="w">
</span><span class="n">tree</span> <span class="o">=</span> <span class="n">MyTransformer</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="w">
</span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre>
<p>The script will print the new source, with an <tt class="docutils literal">import time</tt> replacing the
original <tt class="docutils literal">import asyncio</tt>.</p>
<p>Changing the <tt class="docutils literal">async</tt> call is a bit trickier: we want to change the
highlighted parts of the original tree:</p>
<pre class="literal-block">
<strong>value=Await</strong>(   &lt;&lt; this node must be dropped, replaced by its <strong>value</strong>
   value=Call(
      func=Attribute(
         value=Name(id='<strong>asyncio</strong>'),  &lt;&lt; we want <strong>time</strong> here
         attr='sleep'),
      args=[
         Constant(value=1)],
      keywords=[]))),
</pre>
<p>Adding the following two methods to the above class will implement what has
been described.</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">visit_Await</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span><span class="w">
</span>    <span class="n">new_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># drop the node, continue to operate on the value</span><span class="w">
</span>    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span><span class="w">
</span>    <span class="k">return</span> <span class="n">new_node</span><span class="w">

</span><span class="k">def</span> <span class="nf">visit_Call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span><span class="w">
</span>    <span class="k">match</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">:</span><span class="w">
</span>        <span class="k">case</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;asyncio&quot;</span><span class="p">),</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;sleep&quot;</span><span class="p">):</span><span class="w">
</span>            <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="w">
</span>    <span class="k">return</span> <span class="n">node</span>
</pre>
<p>To make sense of how these methods operate on their input nodes, and then to
implement your own transformations, you can always look at the output of
<tt class="docutils literal">python <span class="pre">-m</span> ast</tt> in order to see the attributes on each node and how they are
nested.</p>
<p>The <tt class="docutils literal">visit_Call</tt> method shows how the <a class="reference external" href="https://peps.python.org/pep-0636/">structural pattern matching</a>
introduced in Python 3.10 comes in handy for this operation. The method is
called for each function call found in the input code; checking whether the
one just received requires any manipulation would have involved a cascade of
ifs (the value is a <tt class="docutils literal">Name</tt>, its id is <tt class="docutils literal">asyncio</tt>, the attr is <tt class="docutils literal">sleep</tt>...)
which becomes pretty ugly pretty quickly, whereas instead a <tt class="docutils literal">match</tt>
statement can describe a complex nested test very succinctly.</p>
</div>
<div class="section" id="problems-with-sleep">
<h2>Problems with <tt class="docutils literal">sleep()</tt></h2>
<p>Performing the transformation from <tt class="docutils literal">asyncio.sleep</tt> to <tt class="docutils literal">time.sleep</tt> for
real is much more complex than this. What if our source includes <tt class="docutils literal">from asycio
import sleep, Event</tt>? We would have to split the import into several parts:</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span><span class="w">
</span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Event</span>
</pre>
<p>and the latter should be treated differently later because the two <tt class="docutils literal">Event</tt>
objects have a different <tt class="docutils literal">wait()</tt> signatures.</p>
<p>To help with this operation, in Psycopg 3 we introduced <a class="reference external" href="https://github.com/psycopg/psycopg/blob/d13137aacb82fed79459a9dd487846a2ec972571/psycopg/psycopg/_acompat.py">an internal
'_acompat' module</a> (actually <a class="reference external" href="https://github.com/psycopg/psycopg/blob/d13137aacb82fed79459a9dd487846a2ec972571/psycopg_pool/psycopg_pool/_acompat.py">two</a>, because the pool is released
separately and uses different functions; actually <a class="reference external" href="https://github.com/psycopg/psycopg/blob/d13137aacb82fed79459a9dd487846a2ec972571/tests/acompat.py">three</a>, because the tests
also have their own...) to expose pairs of functions or objects that should be
used alternatively in sync or in async mode.</p>
<p>For example we can solve the <tt class="docutils literal">sleep()</tt> problem with:</p>
<pre class="code python literal-block">
<span class="c1"># module _acompat.py</span><span class="w">

</span><span class="kn">import</span> <span class="nn">time</span><span class="w">
</span><span class="kn">import</span> <span class="nn">asyncio</span><span class="w">

</span><span class="n">sleep</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="w">

</span><span class="k">def</span> <span class="nf">asleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Coroutine</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span><span class="w">
    </span><span class="sd">&quot;&quot;&quot;
    Equivalent to asyncio.sleep(), converted to time.sleep() by async_to_sync.
    &quot;&quot;&quot;</span><span class="w">
</span>    <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</pre>
<p>Now it's easy to use <tt class="docutils literal">from ._acompat import asleep; await asleep(1)</tt> and do
some simple name substitutions in the AST: the resulting statement <tt class="docutils literal">from
._acompat import sleep; sleep(1)</tt> will work as expected.</p>
<p>Other goodies we have implemented to help unify async and sync code are
<tt class="docutils literal">aspawn</tt>/<tt class="docutils literal">spawn</tt> and <tt class="docutils literal">agather</tt>/<tt class="docutils literal">gather</tt> to unify threads and
asyncio tasks creation, <tt class="docutils literal">alist()</tt> to encapsulate <tt class="docutils literal">[x for x in await
iterable]</tt> in a way that can be easily converted to <tt class="docutils literal">list(iterable)</tt> and
many other helpers to smooth the transition.</p>
</div>
<div class="section" id="when-everything-else-fail">
<h2>When everything else fail</h2>
<p>There may be parts of the codebase where the difference between sync and async
versions is too difficult to handle in a practical way, and is not worth to
put together a complex matching for a complex, one-off case. What we want is a
simple &quot;if async, do this, else do that&quot;.</p>
<p>We have solved this problem by using a pattern like:</p>
<pre class="code python literal-block">
<span class="k">if</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># ASYNC</span><span class="w">
</span>    <span class="n">foo</span><span class="p">()</span><span class="w">
</span><span class="k">else</span><span class="p">:</span><span class="w">
</span>    <span class="n">bar</span><span class="p">()</span>
</pre>
<p>The AST with this code, including the comments, looks like:</p>
<pre class="literal-block">
Module(
   body=[
      <strong>If(</strong>
         <strong>test=Constant(value=True),</strong>
         body=[
            <strong>Comment(value='# ASYNC', inline=True),</strong>
            Expr(
               value=Call(
                  func=Name(id='foo'),
                  args=[],
                  keywords=[]))],
         orelse=[
            Expr(
               value=Call(
                  func=Name(id='bar'),
                  args=[],
                  keywords=[]))])],
   type_ignores=[])
</pre>
<p><a class="reference external" href="https://github.com/psycopg/psycopg/blob/d13137aacb82fed79459a9dd487846a2ec972571/tools/async_to_sync.py#L253-L262">Our transformation</a> will find the <tt class="docutils literal">ASYNC</tt> comment: in this case it will
simply discard the if side of the condition, as well as the <tt class="docutils literal">if</tt> itself, and
will leave only the <tt class="docutils literal">else</tt> branch in the sync code, allowing you to discard
unneeded imports or other code that would simply be invalid in the sync
context.</p>
<p>This pattern is also efficient, because the Python compiler is able to
recognise that <tt class="docutils literal">if True</tt> will always take the first branch, so it will
discard the test and the code in the <tt class="docutils literal">else</tt> branch. The <a class="reference external" href="https://docs.python.org/3/library/dis.html">dis</a>(assembler)
module shows no jump and that no reference to the <tt class="docutils literal">bar()</tt> function call:</p>
<pre class="literal-block">
$ python -m dis ast3.py
  1           0 NOP

  2           2 LOAD_NAME                0 (foo)
              4 CALL_FUNCTION            0
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
</pre>
</div>
<div class="section" id="conversion-methodology">
<h2>Conversion methodology</h2>
<p>Once we have our conversion script, how do we use it to actually convert the
code base, making sure to not break it? The process, for us, was
iterative: going module by module and adding features to the script until
all the &quot;duplicated&quot; modules were complete.</p>
<p>For each module to be converted, the procedure was roughly as follows.</p>
<p>First step: refactoring the code with the intention of not changing any
behaviour, but of making the async module as similar as possible to the sync
module. This might have meant some code reorganisation, the renaming of some
variables, the swapping of some function definitions, the rediscovery of some
forgotten skeletons and a chance of giving them a proper burial.</p>
<p>Often we would have implemented some non-I/O related helper function on the
sync side and imported it on the async side:</p>
<pre class="code python literal-block">
<span class="c1"># connection.py</span><span class="w">

</span><span class="k">def</span> <span class="nf">clean_up_conninfo</span><span class="p">(</span><span class="n">conninfo</span><span class="p">):</span><span class="w">
</span>    <span class="o">...</span>  <span class="c1"># hack hack</span><span class="w">
</span>    <span class="k">return</span> <span class="n">better_conninfo</span><span class="w">

</span><span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">conninfo</span><span class="p">):</span><span class="w">
</span>    <span class="n">better_conninfo</span> <span class="o">=</span> <span class="n">clean_up_conninfo</span><span class="p">(</span><span class="n">conninfo</span><span class="p">)</span><span class="w">
</span>    <span class="n">conn</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">connection_gen</span><span class="p">(</span><span class="n">bettern_conninfo</span><span class="p">))</span><span class="w">
</span>    <span class="k">return</span> <span class="n">conn</span><span class="w">

</span><span class="c1"># connection_async.py</span><span class="w">

</span><span class="kn">from</span> <span class="nn">.connection</span> <span class="kn">import</span> <span class="n">clean_up_conninfo</span><span class="w">

</span><span class="k">async</span> <span class="k">def</span> <span class="nf">connect_async</span><span class="p">(</span><span class="n">conninfo</span><span class="p">):</span><span class="w">
</span>    <span class="n">better_conninfo</span> <span class="o">=</span> <span class="n">clean_up_conninfo</span><span class="p">(</span><span class="n">conninfo</span><span class="p">)</span><span class="w">
</span>    <span class="n">aconn</span> <span class="o">=</span> <span class="k">await</span> <span class="n">async_wait</span><span class="p">(</span><span class="n">connection_gen</span><span class="p">(</span><span class="n">bettern_conninfo</span><span class="p">))</span><span class="w">
</span>    <span class="k">return</span> <span class="n">aconn</span>
</pre>
<p>In this case we would have moved the shared functionality in a separate
internal module and imported the function on both the sides:</p>
<pre class="code python literal-block">
<span class="c1"># _connection.py</span><span class="w">

</span><span class="k">def</span> <span class="nf">clean_up_conninfo</span><span class="p">(</span><span class="n">conninfo</span><span class="p">):</span><span class="w">
</span>    <span class="o">...</span>  <span class="c1"># hack hack</span><span class="w">
</span>    <span class="k">return</span> <span class="n">better_conninfo</span><span class="w">

</span><span class="c1"># connection.py</span><span class="w">

</span><span class="kn">from</span> <span class="nn">._connection</span> <span class="kn">import</span> <span class="n">clean_up_conninfo</span><span class="w">

</span><span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">conninfo</span><span class="p">):</span><span class="w">
</span>    <span class="n">better_conninfo</span> <span class="o">=</span> <span class="n">clean_up_conninfo</span><span class="p">(</span><span class="n">conninfo</span><span class="p">)</span><span class="w">
</span>    <span class="n">conn</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">connection_gen</span><span class="p">(</span><span class="n">bettern_conninfo</span><span class="p">))</span><span class="w">
</span>    <span class="k">return</span> <span class="n">conn</span><span class="w">

</span><span class="c1"># connection_async.py</span><span class="w">

</span><span class="kn">from</span> <span class="nn">._connection</span> <span class="kn">import</span> <span class="n">clean_up_conninfo</span><span class="w">

</span><span class="k">async</span> <span class="k">def</span> <span class="nf">connect_async</span><span class="p">(</span><span class="n">conninfo</span><span class="p">):</span><span class="w">
</span>    <span class="n">better_conninfo</span> <span class="o">=</span> <span class="n">clean_up_conninfo</span><span class="p">(</span><span class="n">conninfo</span><span class="p">)</span><span class="w">
</span>    <span class="n">aconn</span> <span class="o">=</span> <span class="k">await</span> <span class="n">async_wait</span><span class="p">(</span><span class="n">connection_gen</span><span class="p">(</span><span class="n">bettern_conninfo</span><span class="p">))</span><span class="w">
</span>    <span class="k">return</span> <span class="n">aconn</span>
</pre>
<p>Now that the two modules are more similar we can run the test suite to verify
that the library still works and can commit the current state to git.</p>
<p>Second step: run an async -&gt; sync conversion with the current version of the
script. Even running a no-op script is useful: it produces changes that can be
easily seen with <tt class="docutils literal">git diff</tt>, suggesting which conversion feature is missing,
or what further cleanup we could have done in the code to make the sync and
async flavours more similar.</p>
<p>For example, a no-op script that just copies the async side to the sync
side, would show up in <tt class="docutils literal">git diff</tt> as:</p>
<pre class="code diff literal-block">
<span class="gu">&#64;&#64; -1,6 +1,6 &#64;&#64;</span><span class="w">
 </span>from ._connection import clean_up_conninfo<span class="w">

</span><span class="gd">-def connect(conninfo):</span><span class="w">
</span><span class="gi">+async def connect_async(conninfo):</span><span class="w">
 </span>    better_conninfo = clean_up_conninfo(conninfo)<span class="w">
</span><span class="gd">-    conn = wait(connection_gen(bettern_conninfo))</span><span class="w">
</span><span class="gd">-    return conn</span><span class="w">
</span><span class="gi">+    aconn = await async_wait(connection_gen(bettern_conninfo))</span><span class="w">
</span><span class="gi">+    return aconn</span>
</pre>
<p>The first feature to add to the conversion script is to remove the <tt class="docutils literal">async</tt>
and <tt class="docutils literal">await</tt> keywords. Run the conversion and diff again and you will see:</p>
<pre class="code diff literal-block">
<span class="gu">&#64;&#64; -1,6 +1,6 &#64;&#64;</span><span class="w">
 </span>from ._connection import clean_up_conninfo<span class="w">

</span><span class="gd">-def connect(conninfo):</span><span class="w">
</span><span class="gi">+def connect_async(conninfo):</span><span class="w">
 </span>    better_conninfo = clean_up_conninfo(conninfo)<span class="w">
</span><span class="gd">-    conn = wait(connection_gen(bettern_conninfo))</span><span class="w">
</span><span class="gd">-    return conn</span><span class="w">
</span><span class="gi">+    aconn = async_wait(connection_gen(bettern_conninfo))</span><span class="w">
</span><span class="gi">+    return aconn</span>
</pre>
<p>The next step is some renaming. If <tt class="docutils literal">connect()</tt> and <tt class="docutils literal">connect_async()</tt>
are public functions we don't want to change their names. The script should
have a name mapping function suggesting to convert:</p>
<ul class="simple">
<li><tt class="docutils literal">connect_async</tt> -&gt; <tt class="docutils literal">connect</tt></li>
<li><tt class="docutils literal">wait_async</tt> -&gt; <tt class="docutils literal">wait</tt></li>
</ul>
<p>Implementing this renaming in the AST we would bring us to the diff:</p>
<pre class="code diff literal-block">
<span class="gu">&#64;&#64; -2,5 +2,5 &#64;&#64;</span><span class="w">

 </span>def connect(conninfo):<span class="w">
 </span>    better_conninfo = clean_up_conninfo(conninfo)<span class="w">
</span><span class="gd">-    conn = wait(libpq.connect_async())</span><span class="w">
</span><span class="gd">-    return conn</span><span class="w">
</span><span class="gi">+    aconn = async(libpq.connect_async())</span><span class="w">
</span><span class="gi">+    return aconn</span>
</pre>
<p>We are getting there. This remaining <tt class="docutils literal">aconnn</tt>/<tt class="docutils literal">conn</tt> is actually a
gratuitous difference: we can change the async side and call the local
variable <tt class="docutils literal">conn</tt> without losing readability and obviously without changing
any behaviour.</p>
<p>Committing the change on the async side and re-running the conversion would
show no more difference on the sync side. At this point we can commit the
whole project (any remaining but acceptable change on the sync side, the new
features added to the conversion script, new entries in the renaming
mapping...), run the tests to verify that no regression has been introduced,
and move on to the next module.</p>
<p>This operation, in Psycopg 3, started at commit <a class="reference external" href="https://github.com/psycopg/psycopg/commit/765f663f171bf5d5e4862d5c4a5d572b7e3227d8">765f663f</a> and can be seen in
the git history as a parallel branch that was eventually merged in <a class="reference external" href="https://github.com/psycopg/psycopg/commit/8bb0f9bfef945861e8f671fba9073b3fae45c67f">8bb0f9bf</a>.
The <tt class="docutils literal">diff <span class="pre">--stat</span></tt> shows a whopping:</p>
<pre class="literal-block">
99 files changed, 9697 insertions(+), 8486 deletions(-)
</pre>
<p>which is obviously a monster changeset, but mostly consists of incremental
refactorings, conversions, finding new ways to minimise differences. It could
be an interesting ride if you have a project where you need to introduce
a similar automatic conversion.</p>
</div>
<div class="section" id="the-final-result">
<h2>The final result</h2>
<p>Here is the <a class="reference external" href="https://github.com/psycopg/psycopg/blob/3.2.0/tools/async_to_sync.py">Psycopg 3 async to sync conversion script</a> (as of the <a class="reference external" href="https://www.psycopg.org/articles/2024/06/30/psycopg-32-released/">Psycopg
3.2 release</a>). At the time of writing, It processes 27 files and
automatically generates about the 25% of the codebase. Some of the features it
boasts:</p>
<ul>
<li><p class="first">the AST transformations described above, including tricks like recursion
into strings containing code to be transformed, such as Mypy annotations
expressed as strings, adjusting the output and the comments to make the
resulting unparsed code almost as good as the handwritten side;</p>
</li>
<li><p class="first">it inserts non-essential whitespace, and runs <a class="reference external" href="https://black.readthedocs.io/">black</a> on the output, in
order to make the resulting code as uniform as possible to the original and
as good for humans to work with (to read, debug, diff, etc);</p>
</li>
<li><p class="first">since different Python versions may generate different ASTs and different
output code, it can run in a Docker container, whose image is created on the
fly using as base the Python image of the reference version;</p>
</li>
<li><p class="first">it adds a useful disclaimer to the top of the file:</p>
<pre class="code python literal-block">
<span class="c1"># WARNING: this file is auto-generated by 'async_to_sync.py'</span><span class="w">
</span><span class="c1"># from the original file 'connection_async.py'</span><span class="w">
</span><span class="c1"># DO NOT CHANGE! Change the original file instead.</span>
</pre>
</li>
<li><p class="first">it has a &quot;check&quot; mode that runs in Github Action upon every commit, as part
of the lint step, and will fail if it finds any files to convert that haven't
been committed;</p>
</li>
<li><p class="first">the check mode has its own check: if any script containing the above disclaimer
is not included in the list of files to be converted, it will throw an
error (because a converted file has not been added to the automatic
conversion list);</p>
</li>
<li><p class="first">the check of the check also has its own check! If no file with the
disclaimer is found then it means that something is wrong... Maybe the
disclaimer has been rewritten and the check doesn't work anymore;</p>
</li>
<li><p class="first">it can run in parallel and only on the files that have changed. Almost as
good as <tt class="docutils literal">make</tt> (but for certain tasks it is useful to have all the input
files at once, therefore, &quot;better than <tt class="docutils literal">make</tt>&quot;).</p>
</li>
</ul>
<p>The code is specific to the Psycopg 3 codebase and formatting style, so it's
probably not ready to be used as it is in other projects. But it is probably a
good starting point to to your own conversion: change the list of files to
process, the name mapping, and you should be good to start.</p>
<p>Hope this helps. Happy hacking!</p>
</div>

    
  
  </div>

  
    
  <div class="article">
  
    <h2><a href="/articles/2024/05/08/psycopg3-pipeline-mode/">Pipeline mode in Psycopg</a></h2>
  
  <p class="header">
    Posted by Denis Laxalde on 2024-05-08
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/psycopg3/"
          >psycopg3</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>
      
    
  </p>
  
    <p><a class="reference external" href="https://www.psycopg.org/articles/2022/08/30/psycopg-31-released/">Version 3.1</a> of Psycopg added support for <a class="reference external" href="https://www.postgresql.org/docs/current/libpq-pipeline-mode.html">libpq pipeline mode</a>, bringing
significant performance boost, especially when network latency is important.
In this article, weâ€™ll briefly describe how it works from usersâ€™ perspective
and <em>under the hood</em> while also providing a few implementation details.</p>

    
    <p class="read-more"><a href="/articles/2024/05/08/psycopg3-pipeline-mode/">Read more...</a></p>
    
  
  </div>

  
    
  <div class="article">
  
    <h2><a href="/articles/2021/08/02/psycopg3-django-driver/">Building a Django driver for Psycopg 3</a></h2>
  
  <p class="header">
    Posted by Daniele Varrazzo on 2021-08-02
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/psycopg3/"
          >psycopg3</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>,
      <a class="tag" href="/articles/tag/recipe/"
          >recipe</a>
      
    
  </p>
  
    <p>One of the goals of the <a class="reference external" href="https://www.psycopg.org/psycopg3/">Psycopg 3 project</a> is to make easy to port code
developed from Psycopg 2. For this reason the creation of a Django backend
(the module you specify in the settings as your <a class="reference external" href="https://docs.djangoproject.com/en/3.2/ref/settings/#databases">database ENGINE</a>) was
a project with a double goal:</p>
<ul class="simple">
<li>A Django driver is a way to make Psycopg 3 useful from the start, with the
possibility of dropping it in a project transparently and have available,
when needed the new features offered (for instance the superior <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/basic/copy.html">COPY
support</a>).</li>
<li>The difficulty of introducing Psycopg 3 in the Django codebase and the type
of changes required are indicative of the type of problems that could be
found porting other projects.</li>
</ul>
<p>...and it's done! A few days ago, the new <a class="reference external" href="https://github.com/dvarrazzo/django-psycopg3-backend">Psycopg 3 Django backend</a> could
pass the entire Django test suite!</p>

    
    <p class="read-more"><a href="/articles/2021/08/02/psycopg3-django-driver/">Read more...</a></p>
    
  
  </div>

  
    
  <div class="article">
  
    <h2><a href="/articles/2021/01/17/pool-design/">Designing a connection pool for psycopg3</a></h2>
  
  <p class="header">
    Posted by Daniele Varrazzo on 2021-01-17
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/psycopg3/"
          >psycopg3</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>
      
    
  </p>
  
    <p>The <a class="reference external" href="https://www.psycopg.org/docs/pool.html">psycopg2 pool</a> is a pretty simple object, little more than... a pool of
open connections, and I think it falls short in several ways:</p>
<ul class="simple">
<li>the top usability problem is the fact that it cannot be used as context
manager;</li>
<li>if a connection is broken it is not noticed it until it is used by a client;</li>
<li>if <tt class="docutils literal">minconn</tt> connections are already taken, a new one is created and
disposed of as soon as finished using, regardless of whether other clients
may need it;</li>
<li>if more than <tt class="docutils literal">maxconn</tt> connections are requested the client will receive
an error.</li>
</ul>
<p>For <tt class="docutils literal">psycopg3</tt> I would like something better. I have read around, looking
into other pool implementations to figure out what a well designed connection
pool ought to do (a very well thought one seems the Java <a class="reference external" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>) and
these are a few ideas I'd like to work on: they are here for a feedback,
before I jump into enthusiastically implementing the wrong thing...</p>

    
    <p class="read-more"><a href="/articles/2021/01/17/pool-design/">Read more...</a></p>
    
  
  </div>

  
    
  <div class="article">
  
    <h2><a href="/articles/2020/11/24/psycopg3-adaptation/">The psycopg3 adaptation system</a></h2>
  
  <p class="header">
    Posted by Daniele Varrazzo on 2020-11-24
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/psycopg3/"
          >psycopg3</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>,
      <a class="tag" href="/articles/tag/news/"
          >news</a>
      
    
  </p>
  
    <p>The adaptation system between Python objects and PostgreSQL types is at the
core of <tt class="docutils literal">psycopg2</tt> and <tt class="docutils literal">psycopg3</tt>. The flexibility of the <tt class="docutils literal">psycopg2</tt>
adaptation system provides <a class="reference external" href="https://www.psycopg.org/docs/usage.html#adaptation-of-python-values-to-sql-types">good out-of-the-box object mapping</a> and allows
users to <a class="reference external" href="https://www.psycopg.org/docs/advanced.html#adapting-new-python-types-to-sql-syntax">customise it to suit any need</a>. Do you want your <tt class="docutils literal">decimal</tt>
numbers returned as <tt class="docutils literal">float</tt> because you need speed over pennies? Do you want
to map PostgreSQL Infinity dates to the 25th of December 3099? That's
certainly doable.</p>
<blockquote>
</blockquote>
<p>The <tt class="docutils literal">psycopg3</tt> adaptation system needs some modification compared to
<tt class="docutils literal">psycopg2</tt>, because <tt class="docutils literal">psycopg3</tt> uses the &quot;extended query protocol&quot; to send
query parameters separately from the query. Together, with the differences to
accommodate, there is also a chance to improve a system that has been in use
for several years and has shown its shortcomings together with its strengths.</p>

    
    <p class="read-more"><a href="/articles/2020/11/24/psycopg3-adaptation/">Read more...</a></p>
    
  
  </div>

  
    
  <div class="article">
  
    <h2><a href="/articles/2020/11/15/psycopg3-copy/">The new COPY support in psycopg3</a></h2>
  
  <p class="header">
    Posted by Daniele Varrazzo on 2020-11-15
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/psycopg3/"
          >psycopg3</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>,
      <a class="tag" href="/articles/tag/news/"
          >news</a>
      
    
  </p>
  
    <p><tt class="docutils literal">psycopg2</tt> allows <a class="reference external" href="https://www.psycopg.org/docs/usage.html#copy">interaction with PostgreSQL COPY commands</a>. However
what is possible to do with them is relatively limited: the only possible
interaction is with file-like objects:</p>
<ul class="simple">
<li>there is no adaptation from Python objects to PostgreSQL, as there is for
normal queries: data must be formatted &quot;manually&quot; by the user;</li>
<li>psycopg2 &quot;pulls&quot; data from the file: writing a system that produces data and
pushes it into PostgreSQL is a very contrived operation, requiring to write
a blocking file-like object;</li>
<li>there is no support for <a class="reference external" href="https://github.com/psycopg/psycopg2/issues/428">asynchronous copy</a>.</li>
</ul>
<p><a class="reference external" href="/psycopg3/">psycopg3</a> <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/basic/copy.html#copy">addresses these shortcomings</a> and makes it easy to write Python
programs producing data and pushing it efficiently to the database using the
<tt class="docutils literal">COPY</tt> protocol.</p>

    
    <p class="read-more"><a href="/articles/2020/11/15/psycopg3-copy/">Read more...</a></p>
    
  
  </div>

  
    
  <div class="article">
  
    <h2><a href="/articles/2010/11/02/new-features-upcoming-psycopg-release/">New features in the upcoming Psycopg release</a></h2>
  
  <p class="header">
    Posted by Daniele Varrazzo on 2010-11-02
    
      <br />
      Tagged as
      <a class="tag" href="/articles/tag/news/"
          >news</a>,
      <a class="tag" href="/articles/tag/development/"
          >development</a>
      
    
  </p>
  
    <p>There are several new features being prepared in the upcoming Psycopg version. The <a class="reference external" href="/docs/">documentation</a> refers to it as release 2.2.3 but it may be ultimately released as 2.3. The main target of the release is to expose some of the new features introduced in <a class="reference external" href="https://www.postgresql.org/about/news.1235">PostgreSQL 9.0</a>.</p>

    
    <p class="read-more"><a href="/articles/2010/11/02/new-features-upcoming-psycopg-release/">Read more...</a></p>
    
  
  </div>

  

        </div>
      </div>
      <a style="display:none" rel="me" href="https://fosstodon.org/@psycopg">Mastodon</a>
    </div>

    <footer>
      <div style="margin-bottom:0">
        <p>Â© Copyright 2010â€”2023 by Daniele Varrazzo (at gmail), The Psycopg Team.</p>
      </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
  </body>
</html>

